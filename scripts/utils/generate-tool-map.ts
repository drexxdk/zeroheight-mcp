#!/usr/bin/env tsx

import { promises as fs } from "fs";
import path from "path";

const ROOT = path.resolve(process.cwd());
const TOOLS_DIR = path.join(ROOT, "src", "tools");
const OUT_FILE = path.join(ROOT, "scripts", "utils", "toolTypes.ts");

function toModulePath(filePath: string): string {
  // convert absolute path to import path like '@/tools/.../file'
  const rel = path
    .relative(path.join(ROOT, "src"), filePath)
    .replace(/\\/g, "/");
  if (rel.endsWith("index.ts")) {
    return `@/${path.dirname(rel)}`.replace(/\\/g, "/");
  }
  return `@/${rel.replace(/\.ts$/, "")}`;
}

async function walk(dir: string): Promise<string[]> {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  const files: string[] = [];
  for (const e of entries) {
    const res = path.join(dir, e.name);
    if (e.isDirectory()) files.push(...(await walk(res)));
    else if (e.isFile() && res.endsWith(".ts")) files.push(res);
  }
  return files;
}

function extractExports(text: string): string[] {
  const exports = new Set<string>();
  const constRe = /export\s+const\s+([A-Za-z0-9_]+Tool)\b/g;
  let m;
  while ((m = constRe.exec(text))) exports.add(m[1]);

  const reExportRe = /export\s+\{([^}]+)\}\s*from\s*["']([^"']+)["']/g;
  while ((m = reExportRe.exec(text))) {
    const names = m[1].split(",").map((s) => s.trim().split(" as ")[0].trim());
    for (const n of names) if (n.endsWith("Tool")) exports.add(n);
  }

  return Array.from(exports);
}

async function main(): Promise<void> {
  const files = await walk(TOOLS_DIR);
  const map = new Map<string, Set<string>>();
  for (const f of files) {
    const txt = await fs.readFile(f, "utf8");
    const exps = extractExports(txt);
    if (exps.length === 0) continue;
    const mod = toModulePath(f);
    const set = map.get(mod) ?? new Set<string>();
    exps.forEach((e) => set.add(e));
    map.set(mod, set);
  }

  const mods = Array.from(map.entries());
  const imports: string[] = [];
  const bodyLines: string[] = [];
  mods.forEach(([modPath, exportsSet], idx) => {
    const varName = `Mod${idx}`;
    imports.push(`import type * as ${varName} from \"${modPath}\";`);
    bodyLines.push(`  \"${modPath}\": {`);
    for (const ex of Array.from(exportsSet).sort()) {
      bodyLines.push(`    ${ex}: {`);
      bodyLines.push(
        `      input: Parameters<typeof ${varName}.${ex}.handler>[0];`,
      );
      bodyLines.push(
        `      output: Awaited<ReturnType<typeof ${varName}.${ex}.handler>>;`,
      );
      bodyLines.push(`      handler: typeof ${varName}.${ex}.handler;`);
      bodyLines.push(`    };`);
    }
    bodyLines.push(`  };`);
  });

  const content = `// AUTO-GENERATED by scripts/utils/generate-tool-map.ts - do not edit
import type { z } from "zod";

${imports.join("\n")}

export type ToolMap = {
${bodyLines.join("\n")}
};

export type KnownModule = keyof ToolMap;
export type KnownExport<M extends KnownModule> = keyof ToolMap[M] & string;
`;

  await fs.writeFile(OUT_FILE, content, "utf8");
  process.stdout.write(`Wrote ${OUT_FILE}\n`);
}

main().catch((e) => {
  process.stderr.write(String(e) + "\n");
  process.exit(1);
});
